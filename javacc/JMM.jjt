options {
    LOOKAHEAD=1;
}

PARSER_BEGIN(JMM)

public class JMM {

}

PARSER_END(JMM)

SKIP : {
    " " | "\r" | "\t" | "\n"
}

// Keywords

TOKEN : {
    <IMPORT: "import"> |
    <CLASS: "class"> |
    <EXTENDS: "extends"> |
    <PUBLIC: "public"> |
    <RETURN: "return"> |
    <STATIC: "static"> |
    <VOID: "void"> |
    <MAIN: "main"> |
    <STRING: "String"> |
    <TRUE: "true"> |
    <FALSE: "false"> |
    <INT: "int"> |
    <BOOLEAN: "boolean"> |
    <IF: "if"> |
    <ELSE: "else"> |
    <WHILE: "while"> |
    <THIS: "this"> |
    <NEW: "new"> |
    <LENGTH: "length">
}

// Delimiters

TOKEN : {
    <LEFT_PARENTHESES: "("> |
    <RIGHT_PARENTHESES: ")"> |
    <LEFT_BRACE: "{"> |
    <RIGHT_BRACE: "}"> |
    <LEFT_BRACKET: "["> |
    <RIGHT_BRACKET: "]"> |
    <SEMICOLON: ";"> |
    <COMMA: ",">
}

// Operators

TOKEN : {
    <ADD: "+"> |
    <SUB: "-"> |
    <MUL: "*"> |
    <DIV: "/"> |
    <ASSIGN: "="> |
    <DOT: "."> |
    <NOT: "!"> |
    <AND: "&&"> |
    <LT: "<">
}

// Symbols

TOKEN: {
    <IDENTIFIER: ["A"-"Z", "a"-"z"](["0"-"9", "A"-"Z", "a"-"z", "_"])*> |
    <INTEGER: (["0"-"9"])+> |
    <LF: "\n">
}

void Program(): {} {
    ImportDeclaration() |
    ClassDeclaration() |
    <EOF>
}

void ImportDeclaration(): {} {
    <IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON>
}

void ClassDeclaration(): {} {
    <CLASS> <IDENTIFIER> ("extends" <IDENTIFIER>)?
    <LEFT_BRACE> ( VarDeclaration() )? ( MethodDeclaration() )? <RIGHT_BRACE>
}

void VarDeclaration(): {} {
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration(): {} {
    (
        <PUBLIC> Type() <IDENTIFIER> <LEFT_PARENTHESES>
        ( Type() <IDENTIFIER> ("," Type() <IDENTIFIER>)* )?
        <RIGHT_PARENTHESES> <LEFT_BRACE>
        ( VarDeclaration() )*
        ( Statement() )*
        <RETURN> Expression() <SEMICOLON> <RIGHT_BRACE>
    ) |
    (
        <PUBLIC> <STATIC> <VOID> <MAIN>
        <LEFT_PARENTHESES> <STRING> <LEFT_BRACKET> <RIGHT_BRACKET> <IDENTIFIER> <RIGHT_PARENTHESES> <LEFT_BRACE>
        ( VarDeclaration() )*
        ( Statement() )*
        <RIGHT_BRACE>
    )
}

void Type(): {} {
    ( <INT> <LEFT_BRACKET> <RIGHT_BRACKET> ) |
    <BOOLEAN> |
    <INT> |
    <IDENTIFIER>
}

void Statement(): {} {
    ( <LEFT_BRACE> ( Statement() )* <RIGHT_BRACE> ) |
    ( <IF> <LEFT_PARENTHESES> Expression() <RIGHT_PARENTHESES> Statement() <ELSE> Statement() ) |
    ( <WHILE> <LEFT_PARENTHESES> Expression() <RIGHT_PARENTHESES> Statement() ) |
    ( Expression() <SEMICOLON> ) |
    ( <IDENTIFIER> <ASSIGN> Expression() <SEMICOLON> ) |
    ( <IDENTIFIER> <LEFT_BRACKET> Expression() <RIGHT_BRACKET> <ASSIGN> Expression() <SEMICOLON> )
}

SimpleNode Expression(): {} {
    ( Expression() ( <AND> | <LT> | <ADD> | <SUB> | <MUL> | <DIV> ) Expression() ) |
    ( Expression() <LEFT_BRACKET> Expression() <RIGHT_BRACKET> ) |
    ( Expression() <DOT> <LENGTH> ) |
    ( Expression() <DOT> <IDENTIFIER> <LEFT_PARENTHESES> ( Expression() ( <COMMA> Expression() )* )? <RIGHT_PARENTHESES> ) |
    <INTEGER> |
    <TRUE> |
    <FALSE> |
    <IDENTIFIER> |
    <THIS> |
    ( <NEW> <INT> <LEFT_BRACKET> Expression() <RIGHT_BRACKET> ) |
    ( <NEW> <IDENTIFIER> <LEFT_PARENTHESES> <RIGHT_PARENTHESES>) |
    ( <NOT> Expression() ) |
    ( <LEFT_PARENTHESES> Expression() <RIGHT_PARENTHESES> )
}