options {
    LOOKAHEAD=1;
}

PARSER_BEGIN(JMM)

public class JMM {
    public static void main(String[] args) throws ParseException {
        System.out.println("Write a Java-- program:");
        JMM jmm = new JMM(System.in);

        SimpleNode root = jmm.Program(); // Returns reference to root node
        root.dump(""); // Prints the tree on the screen

        System.out.println("Finished parsing");
    }
}

PARSER_END(JMM)

SKIP : {
    " " | "\r" | "\t" | "\n"
}

// Multi-line comment

SKIP : {
    "/*" : WithinComment
}

<WithinComment> SKIP : {
    "*/" : DEFAULT
}

<WithinComment> MORE : {
    <~[]>
}

// Single-line comment

SPECIAL_TOKEN : {
    <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n"|"\r"|"\r\n")>
}

// Keywords

TOKEN : {
    <IMPORT: "import"> |
    <CLASS: "class"> |
    <EXTENDS: "extends"> |
    <PUBLIC: "public"> |
    <RETURN: "return"> |
    <STATIC: "static"> |
    <VOID: "void"> |
    <MAIN: "main"> |
    <STRING: "String"> |
    <TRUE: "true"> |
    <FALSE: "false"> |
    <INT: "int"> |
    <BOOLEAN: "boolean"> |
    <IF: "if"> |
    <ELSE: "else"> |
    <WHILE: "while"> |
    <THIS: "this"> |
    <NEW: "new"> |
    <LENGTH: "length">
}

// Delimiters

TOKEN : {
    <LEFT_PARENTHESES: "("> |
    <RIGHT_PARENTHESES: ")"> |
    <LEFT_BRACE: "{"> |
    <RIGHT_BRACE: "}"> |
    <LEFT_BRACKET: "["> |
    <RIGHT_BRACKET: "]"> |
    <SEMICOLON: ";"> |
    <COMMA: ",">
}

// Operators

TOKEN : {
    <ADD: "+"> |
    <SUB: "-"> |
    <MUL: "*"> |
    <DIV: "/"> |
    <ASSIGN: "="> |
    <DOT: "."> |
    <NOT: "!"> |
    <AND: "&&"> |
    <LT: "<">
}

// Symbols

TOKEN: {
    <IDENTIFIER:
        (["A"-"Z", "a"-"z", "$"](["0"-"9", "A"-"Z", "a"-"z", "$", "_"])*) |
        (["_"](["0"-"9", "A"-"Z", "a"-"z", "$", "_"])+)
    > |
    <INTEGER: (["0"-"9"])+>
}

SimpleNode Program(): {} {
    ImportDeclaration()
    ClassDeclaration()
    <EOF>
    { return jjtThis; }
}

void ImportDeclaration() #void: {} {
    (<IMPORT> <IDENTIFIER> (<DOT> <IDENTIFIER>)* <SEMICOLON> #ImportDeclaration)*
}

void ClassDeclaration(): {} {
    <CLASS> <IDENTIFIER> [ "extends" <IDENTIFIER> ]
    <LEFT_BRACE> ( VarDeclaration() )* ( MethodDeclaration() )* <RIGHT_BRACE>
}

void VarDeclaration(): {} {
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration(): {} {
    <PUBLIC>
    (
        (
            <STATIC> <VOID> <MAIN>
            <LEFT_PARENTHESES> <STRING> <LEFT_BRACKET> <RIGHT_BRACKET> <IDENTIFIER> <RIGHT_PARENTHESES> <LEFT_BRACE>
            MethodBody()
        ) |
        (
            Type() <IDENTIFIER> <LEFT_PARENTHESES>
            [ Type() <IDENTIFIER> ("," Type() <IDENTIFIER>)* ]
            <RIGHT_PARENTHESES> <LEFT_BRACE>
            MethodBody()
            <RETURN> Expression() <SEMICOLON>
        )
    )
    <RIGHT_BRACE>
}

void MethodBody(): {} {
    ( LOOKAHEAD(2) VarDeclaration() )*
    ( Statement() )*
}

void Type(): {} {
    ( <INT> [<LEFT_BRACKET> <RIGHT_BRACKET>] ) |
    <BOOLEAN> |
    <IDENTIFIER>
}

void Statement(): {} {
    ( <LEFT_BRACE> ( Statement() )* <RIGHT_BRACE> ) |
    ( <IF> <LEFT_PARENTHESES> Expression() <RIGHT_PARENTHESES> Statement() <ELSE> Statement() ) |
    ( <WHILE> <LEFT_PARENTHESES> Expression() <RIGHT_PARENTHESES> Statement() ) |
    LOOKAHEAD(2)
    <IDENTIFIER> [ <LEFT_BRACKET> Expression() <RIGHT_BRACKET> ] <ASSIGN> Expression() <SEMICOLON> |
    Expression() <SEMICOLON>
}

void Expression() #void: {} {
    LT() (<AND> LT() #And(2))*
}

void LT() #void: {} {
    AddSub() (<LT> AddSub() #Less_Than(2))*
}

void AddSub() #void: {} {
    MultDiv() (<ADD> MultDiv() #Add(2) | <SUB> MultDiv() #Sub(2) )*
}

void MultDiv() #void: {} {
    Negate() (<MUL> Negate() #Mul(2) | <DIV> Negate() #Div(2) )*
}

void Negate() #void: {}  {
    (<NOT>)* Length() #Negate
}

void Length() #void: {} {
    Parentheses() (<DOT> Call() )*
}

void Parentheses() #void: {} {
    ( <LEFT_PARENTHESES> Expression() <RIGHT_PARENTHESES> ) |
    ( <LEFT_BRACKET> Expression() <RIGHT_BRACKET> ) |
    _Expression()
}

void Call(): {} {
    "length" |
    (<IDENTIFIER> <LEFT_PARENTHESES> [ Expression() ( <COMMA> Expression() )* ] <RIGHT_PARENTHESES> )
}

void _Expression() #void: {} {
    (
        <INTEGER> #Int           |
        <TRUE> #True             |
        <FALSE> #False           |
        <IDENTIFIER> #Identifier |
        <THIS> #This             |
        <NEW>
        (
            "int" <LEFT_BRACKET> Expression() #IntArray <RIGHT_BRACKET> |
            <IDENTIFIER> #VarCreation <LEFT_PARENTHESES> <RIGHT_PARENTHESES>
        )
    )
    __Expression()
}

void __Expression() #Index: {} {
     [ <LEFT_BRACKET> Expression() <RIGHT_BRACKET> __Expression() ]
}